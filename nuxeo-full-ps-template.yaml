apiVersion: v1
kind: Template
message: |-
  The following backing services for Nuxeo have been created in your project:

    * a MongoDB instance
    * an Elasticsearch simple node
    * a dev deployment
    * a uat deployment
    * a CI/CD pipeline build
    * a Release pipeline build

  Please add a Github webhook to https://openshift.<<dev|prod>>.nuxeo.io/oapi/v1/namespaces/<<NAMESPACE>>/buildconfigs/${APPLICATION_NAME}-pipeline/webhooks/${GITHUB_WEBHOOK_SECRET}/github
  For more details, please read the following documentation: https://nuxeowiki.atlassian.net/wiki/spaces/USCC/pages/233406490 and https://nuxeowiki.atlassian.net/wiki/spaces/USCC/pages/233603134
metadata:
  name: nuxeo-full-ps-pipeline
  annotations:
    description: |
      This template sets up a development environment for professional services, including CI, CD and release processes.
    openshift.io/display-name: Nuxeo full PS dev environment
    template.openshift.io/documentation-url: https://github.com/nuxeo/nuxeo-openshift
    template.openshift.io/long-description: |-
      This template sets up a development environment for professional services, including CI, CD and release processes.
    template.openshift.io/provider-display-name: Nuxeo
    template.openshift.io/support-url: https://answers.nuxeo.com/
    iconClass: icon-openshift
    tags: java, nuxeo
parameters:
  - description: The name for the application.
    name: APPLICATION_NAME
    value: my-project
    required: true
  - description: The URL of the repository with your Nuxeo project to build.
    name: SOURCE_REPOSITORY_URL
    value: git@github.com:nuxeo-projects/my-project.git
    required: true
  - description: The ssh private key to access the repository.
    name: SSH_PRIVATEKEY
    required: true
  - description: The reference to checkout.
    name: SOURCE_REPOSITORY_REF
    value: "master"
    required: true
  - description: The Nuxeo version to use. Use the version of the image (latest, 9.2, 8.10...).
    name: NUXEO_VERSION
    value: "9.10"
    required: true
  - description: Github Webhook secret (leave empty and it will be generated).
    name: GITHUB_WEBHOOK_SECRET
    required: true
    from: "[a-zA-Z0-9]{12}"
    generate: "expression"
  - description: A Nuxeo Connect userId passed to the build of the image.
    name: NUXEO_CONNECT_USERNAME
    required: true
  - description: The password of the Nuxeo Connect account passed to the build of the image.
    name: NUXEO_CONNECT_PASSWORD
    required: true
  - description: The name of the studio project passed to the build of the image.
    name: NUXEO_STUDIO_PROJECT
    required: true
  - description: The version of the studio project passed the build of the image.
    name: NUXEO_STUDIO_VERSION
    required: false
    value: master-SNAPSHOT
  - description: The instance.clid of a valid registered instance (needed only if the project runs ftests).
    name: INSTANCE_CLID
    required: false
  - description: The username used for the release commits.
    name: NUXEO_RELEASE_GIT_USERNAME
    value: OpenShift Jenkins
    required: false
  - description: The email used for the release commits.
    name: NUXEO_RELEASE_GIT_EMAIL
    value: openshift_jenkins@test.com
    required: false
  - description: The password of the Nexus admin user who can access and deploy to a Nexus repository.
    name: NEXUS_ADMIN_PASSWORD
    value: admin123
    required: true
  - description: The email of the Nexus admin user.
    name: NEXUS_ADMIN_EMAIL
    value: openshift_nexus@test.com
    required: false
  - description: Size of persistent storage for Nexus.
    name: VOLUME_NEXUS_CAPACITY
    value: 2Gi
    required: true
  - description: Size of persistent storage for Binaries.
    name: VOLUME_BINARIES_CAPACITY
    value: 5Gi
    required: true
  - description: Size of persistent storage for MongoDB.
    name: VOLUME_MONGODB_CAPACITY
    value: 5Gi
    required: true
  - description: Size of persistent storage for Elasticsearch.
    name: VOLUME_ELASTICSEARCH_CAPACITY
    value: 5Gi
    required: true
  - description: Elasticsearch cluster name.
    name: ELASTICSEARCH_CLUSTER_NAME
    value: nuxeo
    required: true
  - description: Elasticsearch Memory.
    name: ELASTICSEARCH_CLUSTER_MEMORY
    value: 256m
    required: true
  - description: Domain suffix for routes. Usually, "apps.dev.nuxeo.io" for openshift.dev and "apps.prod.nuxeo.io" for openshift.prod.
    name: DOMAIN_SUFFIX
    value: apps.prod.nuxeo.io
    required: true
  - description: Storage class for persistence volumes.
    name: STORAGE_CLASS
    value: gp2
    required: true

objects:



############################################################################################################
# Backing services (ES and Mongo)
############################################################################################################

- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: ${APPLICATION_NAME}-elasticsearch-config
    labels:
      app: ${APPLICATION_NAME}-storage
      component: elasticsearch
      role: config
  data:
    elasticsearch.yml: |-
      cluster.name: ${ELASTICSEARCH_CLUSTER_NAME}

      node.data: ${NODE_DATA:true}
      node.master: ${NODE_MASTER:true}
      node.ingest: ${NODE_INGEST:true}
      node.name: ${HOSTNAME}

      network.host: 0.0.0.0

      # see https://github.com/kubernetes/kubernetes/issues/3595
      bootstrap.memory_lock: ${BOOTSTRAP_MEMORY_LOCK:false}

      discovery:
        zen:
          minimum_master_nodes: ${MINIMUM_MASTER_NODES}

      # see https://www.elastic.co/guide/en/x-pack/current/xpack-settings.html
      xpack.ml.enabled: ${XPACK_ML_ENABLED:false}
      xpack.monitoring.enabled: ${XPACK_MONITORING_ENABLED:false}
      xpack.security.enabled: ${XPACK_SECURITY_ENABLED:false}
      xpack.watcher.enabled: ${XPACK_WATCHER_ENABLED:false}

      # see https://github.com/elastic/elasticsearch-definitive-guide/pull/679
      processors: ${PROCESSORS:}

      # avoid split-brain w/ a minimum consensus of two masters plus a data node
      gateway.expected_master_nodes: ${EXPECTED_MASTER_NODES:2}
      gateway.expected_data_nodes: ${EXPECTED_DATA_NODES:1}
      gateway.recover_after_time: ${RECOVER_AFTER_TIME:5m}
      gateway.recover_after_master_nodes: ${RECOVER_AFTER_MASTER_NODES:2}
      gateway.recover_after_data_nodes: ${RECOVER_AFTER_DATA_NODES:1}
    logging.yml: |-
      # you can override this using by setting a system property, for example -Des.logger.level=DEBUG
      es.logger.level: INFO
      rootLogger: ${es.logger.level}, console
      logger:
        # log action execution errors for easier debugging
        action: DEBUG
        # reduce the logging for aws, too much is logged under the default INFO
        com.amazonaws: WARN

      appender:
        console:
          type: console
          layout:
            type: consolePattern
            conversionPattern: "[%d{ISO8601}][%-5p][%-25c] %m%n"
    pre-stop-hook.sh: |-
      #!/bin/bash
      set -e

      SERVICE_ACCOUNT_PATH=/var/run/secrets/kubernetes.io/serviceaccount
      KUBE_TOKEN=$(<${SERVICE_ACCOUNT_PATH}/token)
      KUBE_NAMESPACE=$(<${SERVICE_ACCOUNT_PATH}/namespace)

      STATEFULSET_NAME=$(echo "${HOSTNAME}" | sed 's/-[0-9]*$//g')
      INSTANCE_ID=$(echo "${HOSTNAME}" | grep -o '[0-9]*$')

      echo "Prepare stopping of Pet ${KUBE_NAMESPACE}/${HOSTNAME} of StatefulSet ${KUBE_NAMESPACE}/${STATEFULSET_NAME} instance_id ${INSTANCE_ID}"

      INSTANCES_DESIRED=$(curl -s \
        --cacert ${SERVICE_ACCOUNT_PATH}/ca.crt \
        -H "Authorization: Bearer $KUBE_TOKEN" \
        "https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_PORT_443_TCP_PORT}/apis/apps/v1beta1/namespaces/${KUBE_NAMESPACE}/statefulsets/${STATEFULSET_NAME}/status" | jq -r '.spec.replicas')

      echo "Desired instance count is ${INSTANCES_DESIRED}"

      if [ "${INSTANCE_ID}" -lt "${INSTANCES_DESIRED}" ]; then
        echo "No data migration needed"
        exit 0
      fi

      echo "Prepare to migrate data of the node"

      NODE_STATS=$(curl -s -XGET 'http://localhost:9200/_nodes/stats')
      NODE_IP=$(echo "${NODE_STATS}" | jq -r ".nodes[] | select(.name==\"${HOSTNAME}\") | .host")

      echo "Move all data from node ${NODE_IP}"

      curl -s -XPUT localhost:9200/_cluster/settings -d "{
        \"transient\" :{
            \"cluster.routing.allocation.exclude._ip\" : \"${NODE_IP}\"
        }
      }"
      echo

      echo "Wait for node to become empty"
      DOC_COUNT=$(echo "${NODE_STATS}" | jq ".nodes[] | select(.name==\"${HOSTNAME}\") | .indices.docs.count")
      while [ "${DOC_COUNT}" -gt 0 ]; do
        NODE_STATS=$(curl -s -XGET 'http://localhost:9200/_nodes/stats')
        DOC_COUNT=$(echo "${NODE_STATS}" | jq -r ".nodes[] | select(.name==\"${HOSTNAME}\") | .indices.docs.count")
        echo "Node contains ${DOC_COUNT} documents"
        sleep 1
      done

      echo "Wait for node shards to become empty"
      SHARD_STATS=$(curl -s -XGET 'http://localhost:9200/_cat/shards?format=json')
      SHARD_COUNT=$(echo "${SHARD_STATS}" | jq "[.[] | select(.node==\"${HOSTNAME}\")] | length")
      while [ "${SHARD_COUNT}" -gt 0 ]; do
        SHARD_STATS=$(curl -s -XGET 'http://localhost:9200/_cat/shards?format=json')
        SHARD_COUNT=$(echo "${SHARD_STATS}" | jq "[.[] | select(.node==\"${HOSTNAME}\")] | length")
        echo "Node contains ${SHARD_COUNT} shards"
        sleep 1
      done

      echo "Node clear to shutdown"




- apiVersion: v1
  kind: ServiceAccount
  metadata:
    labels:
      app: ${APPLICATION_NAME}-storage
    name: elasticsearch


# Source: elasticsearch/templates/client-svc.yaml
- apiVersion: v1
  kind: Service
  metadata:
    labels:
      app: ${APPLICATION_NAME}-storage
      component: elasticsearch
      role: client
    name: ${APPLICATION_NAME}-elasticsearch
  spec:
    ports:
      - name: client
        port: 9200
        targetPort: client
    selector:
      app: ${APPLICATION_NAME}-storage
      component: elasticsearch
    type: ClusterIP




  # Source: elasticsearch/templates/data-statefulset.yaml
- apiVersion: apps/v1beta1
  kind: StatefulSet
  metadata:
    labels:
      app: ${APPLICATION_NAME}-storage
      component: elasticsearch
      role: data
    name: ${APPLICATION_NAME}-elasticsearch
  spec:
    serviceName: ${APPLICATION_NAME}-elasticsearch
    replicas: 1
    template:
      metadata:
        labels:
          app: ${APPLICATION_NAME}-storage
          component: elasticsearch
      spec:
        serviceAccountName: elasticsearch
        affinity:
          podAntiAffinity:
            preferredDuringSchedulingIgnoredDuringExecution:
            - weight: 1
              podAffinityTerm:
                topologyKey: kubernetes.io/hostname
                labelSelector:
                  matchLabels:
                    app: ${APPLICATION_NAME}-storage
                    component: elasticsearch
                    role: data
        initContainers:
        # see https://www.elastic.co/guide/en/elasticsearch/reference/current/vm-max-map-count.html
        # and https://www.elastic.co/guide/en/elasticsearch/reference/current/setup-configuration-memory.html#mlockall
        - name: "sysctl"
          image: "busybox"
          imagePullPolicy: "Always"
          command: ["sysctl", "-w", "vm.max_map_count=262144"]
          securityContext:
            privileged: true
        - name: "chown"
          image: "docker.elastic.co/elasticsearch/elasticsearch:5.6.5"
          imagePullPolicy: "IfNotPresent"
          command:
          - /bin/bash
          - -c
          - chown -R elasticsearch:elasticsearch /usr/share/elasticsearch/data &&
            chown -R elasticsearch:elasticsearch /usr/share/elasticsearch/logs
          securityContext:
            runAsUser: 0
          volumeMounts:
          - mountPath: /usr/share/elasticsearch/data
            name: data
        containers:
        - name: elasticsearch
          env:
          - name: KUBERNETES_MASTER
            value: kubernetes.default.svc.cluster.local
          - name: KUBERNETES_NAMESPACE
            valueFrom:
              fieldRef:
                fieldPath: metadata.namespace
          - name: NODE_MASTER
            value: "true"
          - name: PROCESSORS
            valueFrom:
              resourceFieldRef:
                resource: limits.cpu
          - name: EXPECTED_MASTER_NODES
            value: "1"
          - name: RECOVER_AFTER_MASTER_NODES
            value: "1"
          - name: ES_JAVA_OPTS
            value: "-Djava.net.preferIPv4Stack=true -Xms${ELASTICSEARCH_CLUSTER_MEMORY} -Xmx${ELASTICSEARCH_CLUSTER_MEMORY}"
          - name: MINIMUM_MASTER_NODES
            value: "1"
          image: "docker.elastic.co/elasticsearch/elasticsearch:5.6.5"
          imagePullPolicy: "IfNotPresent"
          ports:
          - containerPort: 9200
            name: client
          resources:
              limits:
                cpu: "1"
              requests:
                cpu: 25m
                memory: ${ELASTICSEARCH_CLUSTER_MEMORY}

          readinessProbe:
            httpGet:
              path: /_cluster/health?wait_for_status=yellow
              port: 9200
            initialDelaySeconds: 5
          livenessProbe:
            httpGet:
              path: /_cluster/health?wait_for_status=yellow
              port: 9200
            initialDelaySeconds: 90
          volumeMounts:
          - mountPath: /usr/share/elasticsearch/data
            name: data
          - mountPath: /usr/share/elasticsearch/config/elasticsearch.yml
            name: config
            subPath: elasticsearch.yml
          - mountPath: /usr/share/elasticsearch/config/logging.yml
            name: config
            subPath: logging.yml
          - name: config
            mountPath: /pre-stop-hook.sh
            subPath: pre-stop-hook.sh
          lifecycle:
            preStop:
              exec:
                command: ["/bin/bash","/pre-stop-hook.sh"]
        terminationGracePeriodSeconds: 3600
        volumes:
        - name: config
          configMap:
            name: ${APPLICATION_NAME}-elasticsearch-config
    volumeClaimTemplates:
    - metadata:
        name: data
        labels:
          app: ${APPLICATION_NAME}
        annotations:
          volume.beta.kubernetes.io/storage-class: ${STORAGE_CLASS}
      spec:
        accessModes:
          - "ReadWriteOnce"
        resources:
          requests:
            storage: ${VOLUME_ELASTICSEARCH_CAPACITY}




- apiVersion: v1
  kind: Service
  metadata:
    name: ${APPLICATION_NAME}-mongo
    labels:
      app: ${APPLICATION_NAME}-storage
      component: mongo
  spec:
    ports:
    - port: 27017
      targetPort: 27017
    clusterIP: None
    selector:
      app: ${APPLICATION_NAME}-storage
      component: mongo

- apiVersion: apps/v1beta1
  kind: StatefulSet
  metadata:
    name: ${APPLICATION_NAME}-mongo
  spec:
    serviceName: ${APPLICATION_NAME}-mongo
    replicas: 1
    template:
      metadata:
        labels:
          app: ${APPLICATION_NAME}-storage
          component: mongo
      spec:
        terminationGracePeriodSeconds: 10
        containers:
          - name: mongo
            image: mongo:3.4
            command:
              - mongod
              - "--smallfiles"
              - "--noprealloc"
            ports:
              - containerPort: 27017
            volumeMounts:
              - name: data
                mountPath: /data/db

    volumeClaimTemplates:
    - metadata:
        name: data
        labels:
          app: ${APPLICATION_NAME}-storage
        annotations:
          volume.beta.kubernetes.io/storage-class: ${STORAGE_CLASS}
      spec:
        accessModes: [ "ReadWriteOnce" ]
        resources:
          requests:
            storage: ${VOLUME_MONGODB_CAPACITY}


############################################################################################################
# Nexus service
############################################################################################################

- apiVersion: v1
  kind: Service
  metadata:
    labels:
      app: ${APPLICATION_NAME}-nexus
    name: ${APPLICATION_NAME}-nexus
  spec:
    ports:
      - name: 8081-tcp
        port: 8081
        protocol: TCP
        targetPort: 8081
    selector:
      app: ${APPLICATION_NAME}-nexus
      deploymentconfig: ${APPLICATION_NAME}-nexus
    sessionAffinity: None
    type: ClusterIP

- apiVersion: route.openshift.io/v1
  kind: Route
  metadata:
    annotations:
      openshift.io/host.generated: 'true'
    labels:
      app: ${APPLICATION_NAME}-nexus
    name: ${APPLICATION_NAME}-nexus
  spec:
    host: nexus-${APPLICATION_NAME}.${DOMAIN_SUFFIX}
    path: /nexus
    port:
      targetPort: 8081-tcp
    to:
      kind: Service
      name: ${APPLICATION_NAME}-nexus
      weight: 100
    wildcardPolicy: None

- apiVersion: image.openshift.io/v1
  kind: ImageStream
  metadata:
    labels:
      app: ${APPLICATION_NAME}-nexus
    name: ${APPLICATION_NAME}-nexus
  spec:
    lookupPolicy:
      local: false
    tags:
      - annotations:
          openshift.io/imported-from: sonatype/nexus
        from:
          kind: DockerImage
          name: sonatype/nexus
        importPolicy: {}
        name: latest
        referencePolicy:
          type: Source

- apiVersion: v1
  kind: Secret
  type: kubernetes.io/basic-auth
  metadata:
    labels:
      credential.sync.jenkins.openshift.io: 'true'
    name: ${APPLICATION_NAME}-nexus-credentials
    annotations:
      template.openshift.io/base64-expose-credentials: '{.data}'
  stringData:
    username: admin
    password: ${NEXUS_ADMIN_PASSWORD}

- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: ${APPLICATION_NAME}-nexus-settings
  data:
    security: |-
      <?xml version="1.0" encoding="UTF-8"?>
      <security>
        <version>2.0.5</version>
        <users>
          <user>
            <id>admin</id>
            <firstName>Administrator</firstName>
            <lastName>User</lastName>
            <password>%NEXUS_ADMIN_PASSWORD%</password>
            <status>active</status>
            <email>${NEXUS_ADMIN_EMAIL}</email>
          </user>
        </users>
        <userRoleMappings>
          <userRoleMapping>
            <userId>admin</userId>
            <source>default</source>
            <roles>
              <role>nx-admin</role>
            </roles>
          </userRoleMapping>
        </userRoleMappings>
      </security>

- apiVersion: v1
  kind: PersistentVolumeClaim
  metadata:
    annotations:
      volume.beta.kubernetes.io/storage-class: ${STORAGE_CLASS}
    name: ${APPLICATION_NAME}-nexus-pv
    labels:
      app: ${APPLICATION_NAME}-nexus
  spec:
    accessModes:
    - ReadWriteOnce
    resources:
      requests:
        storage: ${VOLUME_NEXUS_CAPACITY}

- apiVersion: apps.openshift.io/v1
  kind: DeploymentConfig
  metadata:
    labels:
      app: ${APPLICATION_NAME}-nexus
    name: ${APPLICATION_NAME}-nexus
  spec:
    replicas: 1
    revisionHistoryLimit: 10
    selector:
      app: ${APPLICATION_NAME}-nexus
      deploymentconfig: ${APPLICATION_NAME}-nexus
    strategy:
      activeDeadlineSeconds: 21600
      recreateParams:
        timeoutSeconds: 600
      resources: {}
      type: Recreate
    template:
      metadata:
        labels:
          app: ${APPLICATION_NAME}-nexus
          deploymentconfig: ${APPLICATION_NAME}-nexus
      spec:
        containers:
          - image: ${APPLICATION_NAME}-nexus:latest
            imagePullPolicy: Always
            name: ${APPLICATION_NAME}-nexus
            ports:
              - containerPort: 8081
                protocol: TCP
            readinessProbe:
              failureThreshold: 3
              httpGet:
                path: /nexus
                port: 8081
                scheme: HTTP
              initialDelaySeconds: 30
              periodSeconds: 10
              successThreshold: 1
              timeoutSeconds: 1
            resources: {}
            terminationMessagePath: /dev/termination-log
            terminationMessagePolicy: File
            volumeMounts:
              - mountPath: /sonatype-work
                name: nexus-data
        initContainers:
          - image: busybox
            imagePullPolicy: IfNotPresent
            name: ${APPLICATION_NAME}-nexus-work
            command:
              - sh
              - '-c'
              - |-
                mkdir -p /sonatype-work/conf/ && \
                sha1pwd=$(echo -n $NEXUS_ADMIN_PASSWORD | sha1sum | cut -c1-40) && \
                sed -e "s/%NEXUS_ADMIN_PASSWORD%/$sha1pwd/g" \
                /work/security.xml > /sonatype-work/conf/security.xml
            env:
              - name: NEXUS_ADMIN_PASSWORD
                valueFrom:
                  secretKeyRef:
                    key: password
                    name: ${APPLICATION_NAME}-nexus-credentials
            resources: {}
            terminationMessagePath: /dev/termination-log
            terminationMessagePolicy: File
            volumeMounts:
              - mountPath: /sonatype-work
                name: nexus-data
              - mountPath: /work
                name: nexus-configuration
        volumes:
          - name: nexus-data
            persistentVolumeClaim:
              claimName: ${APPLICATION_NAME}-nexus-pv
          - name: nexus-configuration
            configMap:
              items:
                - key: security
                  path: security.xml
              name: ${APPLICATION_NAME}-nexus-settings
    test: false
    triggers:
      - type: ConfigChange
      - imageChangeParams:
          automatic: true
          containerNames:
            - ${APPLICATION_NAME}-nexus
          from:
            kind: ImageStreamTag
            name: ${APPLICATION_NAME}-nexus:latest
        type: ImageChange


############################################################################################################
# Jenkins
############################################################################################################

- apiVersion: image.openshift.io/v1
  kind: ImageStream
  metadata:
    annotations:
      role: jenkins-slave
      slave-label: jenkins-slave
    generation: 1
    labels:
      app: jenkins
      jenkins: slave
      jenkins/maven: 'true'
      role: jenkins-slave
    name: ${APPLICATION_NAME}-jenkins
  spec:
    lookupPolicy:
      local: false

- apiVersion: build.openshift.io/v1
  kind: BuildConfig
  metadata:
    labels:
      component: build
    name: ${APPLICATION_NAME}-jenkins-build
  spec:
    failedBuildsHistoryLimit: 5
    nodeSelector: null
    output:
      to:
        kind: ImageStreamTag
        name: '${APPLICATION_NAME}-jenkins:latest'
    postCommit: {}
    resources: {}
    runPolicy: Serial
    source:
      dockerfile: |-
        FROM docker.io/openshift/jenkins-agent-maven-35-centos7:v3.11
        USER root
        # Install Git
        RUN yum -y install http://opensource.wandisco.com/centos/7/git/x86_64/wandisco-git-release-7-2.noarch.rpm && \
            yum -y install git
        # Install NodeJS
        RUN yum -y install gcc-c++ make && \
            curl -sL https://rpm.nodesource.com/setup_6.x | bash - && \
            yum -y install nodejs
        # Install Chrome
        RUN wget https://dl.google.com/linux/direct/google-chrome-stable_current_x86_64.rpm && \
            yum -y install redhat-lsb libXScrnSaver && \
            yum -y install google-chrome-stable_current_x86_64.rpm
        USER 1000
      secrets:
        - secret:
            name: ${APPLICATION_NAME}-github-ssh
      type: Dockerfile
    strategy:
      dockerStrategy: {}
      type: Docker
    successfulBuildsHistoryLimit: 5
    triggers:
    - type: ConfigChange

- apiVersion: apps.openshift.io/v1
  kind: DeploymentConfig
  metadata:
    annotations:
      template.alpha.openshift.io/wait-for-ready: 'true'
    generation: 7
    labels:
      template: jenkins-ephemeral-template
    name: jenkins
  spec:
    replicas: 1
    selector:
      name: jenkins
    strategy:
      activeDeadlineSeconds: 21600
      recreateParams:
        timeoutSeconds: 600
      resources: {}
      type: Recreate
    template:
      metadata:
        labels:
          name: jenkins
      spec:
        containers:
          - env:
              - name: OPENSHIFT_ENABLE_OAUTH
                value: 'true'
              - name: OPENSHIFT_ENABLE_REDIRECT_PROMPT
                value: 'true'
              - name: KUBERNETES_MASTER
                value: 'https://kubernetes.default:443'
              - name: KUBERNETES_TRUST_CERTIFICATES
                value: 'true'
              - name: JENKINS_SERVICE_NAME
                value: jenkins
              - name: JNLP_SERVICE_NAME
                value: jenkins-jnlp
              - name: INSTALL_PLUGINS
                value: |-
                  maven-plugin, pipeline-maven, file-operations,
                  apache-httpcomponents-client-4-api, junit-attachments, tasks
              - name: NUXEO_RELEASE_GIT_USERNAME
                valueFrom:
                  configMapKeyRef:
                    key: user.name
                    name: ${APPLICATION_NAME}-gitconfig
              - name: NUXEO_RELEASE_GIT_EMAIL
                valueFrom:
                  configMapKeyRef:
                    key: user.email
                    name: ${APPLICATION_NAME}-gitconfig
              - name: SSH_PRIVATEKEY
                valueFrom:
                  secretKeyRef:
                    key: ssh-privatekey
                    name: ${APPLICATION_NAME}-github-ssh
              - name: INSTANCE_CLID
                valueFrom:
                  secretKeyRef:
                    key: instance.clid
                    name: ${APPLICATION_NAME}-instance-clid
            image: ${APPLICATION_NAME}-jenkins:latest
            imagePullPolicy: IfNotPresent
            livenessProbe:
              failureThreshold: 30
              httpGet:
                path: /login
                port: 8080
                scheme: HTTP
              initialDelaySeconds: 420
              periodSeconds: 10
              successThreshold: 1
              timeoutSeconds: 3
            name: jenkins
            readinessProbe:
              failureThreshold: 3
              httpGet:
                path: /login
                port: 8080
                scheme: HTTP
              initialDelaySeconds: 3
              periodSeconds: 10
              successThreshold: 1
              timeoutSeconds: 3
            resources:
              limits:
                memory: 512Mi
            securityContext:
              capabilities: {}
              privileged: false
            terminationMessagePath: /dev/termination-log
            terminationMessagePolicy: File
            volumeMounts:
              - mountPath: /var/lib/jenkins
                name: jenkins-data
              - mountPath: /var/lib/jenkins/configuration
                name: jenkins-configuration
        dnsPolicy: ClusterFirst
        restartPolicy: Always
        schedulerName: default-scheduler
        securityContext: {}
        serviceAccount: jenkins
        serviceAccountName: jenkins
        terminationGracePeriodSeconds: 30
        volumes:
          - name: jenkins-data
            emptyDir: {}
          - name: jenkins-configuration
            configMap:
              defaultMode: 420
              items:
                - key: settings
                  path: settings.xml
              name: ${APPLICATION_NAME}-maven-settings
    test: false
    triggers:
      - imageChangeParams:
          automatic: true
          containerNames:
            - jenkins
          from:
            kind: ImageStreamTag
            name: 'jenkins:latest'
            namespace: openshift
        type: ImageChange
      - type: ConfigChange



############################################################################################################
# Commons
############################################################################################################


- apiVersion: v1
  kind: Secret
  metadata:
    name: ${APPLICATION_NAME}-connect
    labels:
      app: ${APPLICATION_NAME}
  stringData:
    connect.properties: |-
      NUXEO_STUDIO_PROJECT=${NUXEO_STUDIO_PROJECT}
      NUXEO_STUDIO_PROJECT_VERSION=${NUXEO_STUDIO_VERSION}
      NUXEO_CONNECT_USERNAME=${NUXEO_CONNECT_USERNAME}
      NUXEO_CONNECT_PASSWORD=${NUXEO_CONNECT_PASSWORD}

- apiVersion: v1
  kind: Secret
  type: kubernetes.io/basic-auth
  metadata:
    labels:
      app: ${APPLICATION_NAME}
      credential.sync.jenkins.openshift.io: 'true'
    name: ${APPLICATION_NAME}-connect-credentials
    annotations:
      template.openshift.io/base64-expose-credentials: '{.data}'
  stringData:
    username: ${NUXEO_CONNECT_USERNAME}
    password: ${NUXEO_CONNECT_PASSWORD}

- apiVersion: v1
  kind: Secret
  type: kubernetes.io/ssh-auth
  metadata:
    labels:
      app: ${APPLICATION_NAME}
      credential.sync.jenkins.openshift.io: 'true'
    name: ${APPLICATION_NAME}-github-ssh
    annotations:
      template.openshift.io/base64-expose-credentials: '{.data}'
  stringData:
    ssh-privatekey: |-
      ${SSH_PRIVATEKEY}

- apiVersion: v1
  kind: Secret
  type: Opaque
  metadata:
    labels:
      app: ${APPLICATION_NAME}
      credential.sync.jenkins.openshift.io: 'true'
    name: ${APPLICATION_NAME}-instance-clid
    annotations:
      template.openshift.io/base64-expose-credentials: '{.data}'
  stringData:
    instance.clid: |-
      ${INSTANCE_CLID}

- apiVersion: v1
  kind: ImageStream
  metadata:
    name: ${APPLICATION_NAME}-nuxeo
    labels:
      app: ${APPLICATION_NAME}
  spec:
    dockerImageRepository: nuxeo

- apiVersion: v1
  data:
    settings: |-
      <?xml version='1.0' encoding='UTF-8'?>
      <settings>
        <servers>
          <server>
            <id>nuxeo-studio</id>
            <username>${env.NUXEO_CONNECT_USERNAME}</username>
            <password>${env.NUXEO_CONNECT_PASSWORD}</password>
          </server>
          <server>
            <id>hotfix-releases</id>
            <username>${env.NUXEO_CONNECT_USERNAME}</username>
            <password>${env.NUXEO_CONNECT_PASSWORD}</password>
          </server>
          <server>
            <id>external-releases</id>
            <username>${env.NEXUS_ADMIN_USERNAME}</username>
            <password>${env.NEXUS_ADMIN_PASSWORD}</password>
          </server>
        </servers>
        <profiles>
          <profile>
            <id>release</id>
            <properties>
              <external.releases.url>${env.EXTERNAL_RELEASES_URL}</external.releases.url>
            </properties>
          </profile>
        </profiles>
      </settings>
  kind: ConfigMap
  metadata:
    name: ${APPLICATION_NAME}-maven-settings


############################################################################################################
# DEV Deployment
############################################################################################################


- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: ${APPLICATION_NAME}-dev-conf
    labels:
      app: ${APPLICATION_NAME}-dev
      role: config
      stage: dev
  data:
    nuxeo.conf: |
      # Additional nuxeo.conf parameters
    init.sh: |
      #!/bin/sh

      if [ ! -f $NUXEO_DATA/instance.clid -a -f /opt/nuxeo/connect/connect.properties ]; then
        . /opt/nuxeo/connect/connect.properties
        if [ -n "$NUXEO_CONNECT_USERNAME" -a -n "$NUXEO_CONNECT_PASSWORD" -a -n "$NUXEO_STUDIO_PROJECT" ]; then
          echo "---> Registering instance on connect"
          nuxeoctl register $NUXEO_CONNECT_USERNAME $NUXEO_STUDIO_PROJECT dev openshift $NUXEO_CONNECT_PASSWORD
        fi
      fi

- apiVersion: v1
  kind: PersistentVolumeClaim
  metadata:
    name: ${APPLICATION_NAME}-dev-binaries
    labels:
      app: ${APPLICATION_NAME}-dev
      role: data
      stage: dev
  spec:
    accessModes:
    - ReadWriteMany
    resources:
      requests:
        storage: ${VOLUME_BINARIES_CAPACITY}
    storageClassName: shared


- apiVersion: v1
  kind: DeploymentConfig
  metadata:
    labels:
      app: ${APPLICATION_NAME}-dev
      stage: dev
      component: nuxeo
    name: ${APPLICATION_NAME}-dev-nuxeo
  spec:
    strategy:
      type: Rolling
      activeDeadlineSeconds: 21600
      resources: {}
      rollingParams:
        intervalSeconds: 1
        maxSurge: 25%
        maxUnavailable: 25%
        timeoutSeconds: 600
        updatePeriodSeconds: 1
    replicas: 1
    selector:
      app: ${APPLICATION_NAME}-dev
      component: nuxeo
      stage: dev
      deploymentconfig: ${APPLICATION_NAME}-dev-nuxeo

    template:
      metadata:
        labels:
          app: ${APPLICATION_NAME}-dev
          component: nuxeo
          stage: dev
          deploymentconfig: ${APPLICATION_NAME}-dev-nuxeo
      spec:
        containers:
        - image: ${APPLICATION_NAME}-nuxeo:latest
          imagePullPolicy: Always
          livenessProbe:
            httpGet:
              path: /nuxeo/runningstatus
              port: 8080
              scheme: HTTP
            initialDelaySeconds: 30
            timeoutSeconds: 5
            periodSeconds: 10
            successThreshold: 1
            failureThreshold: 3
          readinessProbe:
            failureThreshold: 3
            httpGet:
              path: /nuxeo/runningstatus
              port: 8080
              scheme: HTTP
            initialDelaySeconds: 20
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
          name: ${APPLICATION_NAME}-appserver
          env:
          - name: NUXEO_TEMPLATES
            value: "default,mongodb,mongodb-audit"
          - name: NUXEO_CUSTOM_PARAM
            value: |
              nuxeo.mongodb.server=mongodb://${APPLICATION_NAME}-mongo-0.${APPLICATION_NAME}-mongo:27017
              nuxeo.mongodb.dbname=${APPLICATION_NAME}-dev
              elasticsearch.client=RestClient
              elasticsearch.httpReadOnly.baseUrl=http://${APPLICATION_NAME}-elasticsearch:9200
              elasticsearch.indexName=${APPLICATION_NAME}-dev
              mail.transport.host=aws-smtp-relay.common-infra.svc
              mail.from=noreply@nuxeo.io

          - name: NUXEO_PACKAGES
            value: nuxeo-web-ui
          - name: NUXEO_URL
            value: https://${APPLICATION_NAME}-dev.${DOMAIN_SUFFIX}
          - name: NUXEO_ES_HOSTS
            value: ${APPLICATION_NAME}-elasticsearch:9200
          - name: NUXEO_ES_CLUSTERNAME
            value: ${ELASTICSEARCH_CLUSTER_NAME}
          - name: NUXEO_ES_REPLICAS
            value: "0"
          - name: NUXEO_BINARY_STORE
            value: /binaries

          ports:
          - containerPort: 8080
            protocol: TCP
          volumeMounts:
          - name: ${APPLICATION_NAME}-binaries
            mountPath: /binaries
          - name: nuxeoconf
            mountPath: /docker-entrypoint-initnuxeo.d
          - name: connect-secret
            mountPath: /opt/nuxeo/connect

          - name: nuxeodata
            mountPath: /var/lib/nuxeo/data
          - name: nuxeolog
            mountPath: /var/log/nuxeo
          - name: nuxeotmp
            mountPath: /opt/nuxeo/server/tmp
        volumes:
        - name: ${APPLICATION_NAME}-binaries
          persistentVolumeClaim:
            claimName: ${APPLICATION_NAME}-dev-binaries
        - name: nuxeoconf
          configMap:
            name: ${APPLICATION_NAME}-dev-conf
        - name: connect-secret
          secret:
            secretName: ${APPLICATION_NAME}-connect
        - name: nuxeodata
          emptyDir: {}
        - name: nuxeolog
          emptyDir: {}
        - name: nuxeotmp
          emptyDir: {}
        dnsPolicy: ClusterFirst
        restartPolicy: Always
        terminationGracePeriodSeconds: 30
    test: false
    triggers:
    - type: ConfigChange
    - type: "ImageChange"
      imageChangeParams:
        automatic: false
        containerNames:
        - ${APPLICATION_NAME}-appserver
        from:
          kind: ImageStreamTag
          name: ${APPLICATION_NAME}-nuxeo:latest

- apiVersion: v1
  kind: Service
  metadata:
    name: ${APPLICATION_NAME}-dev-nuxeo
    labels:
      app: ${APPLICATION_NAME}-dev
      component: nuxeo
      role: lb
  spec:
    clusterIP: None
    selector:
      app: ${APPLICATION_NAME}-dev
      component: nuxeo
      stage: dev
    ports:
    - name: 8080-tcp
      port: 8080
      protocol: TCP

- apiVersion: v1
  kind: Route
  metadata:
    labels:
      app: ${APPLICATION_NAME}-dev
    name: ${APPLICATION_NAME}-dev-nuxeo-route
  spec:
    host: ${APPLICATION_NAME}-dev.${DOMAIN_SUFFIX}
    tls:
      termination: edge
      insecureEdgeTerminationPolicy: Redirect
    to:
      kind: Service
      name: ${APPLICATION_NAME}-dev-nuxeo
    port:
      targetPort: 8080-tcp
    wildcardPolicy: None

############################################################################################################
# UAT Deployment
############################################################################################################


- apiVersion: v1
  kind: ConfigMap
  metadata:
    name: ${APPLICATION_NAME}-uat-conf
    labels:
      app: ${APPLICATION_NAME}-uat
      role: config
      stage: dev
  data:
    nuxeo.conf: |
      # Additional nuxeo.conf parameters
    init.sh: |
      #!/bin/sh

      if [ ! -f $NUXEO_DATA/instance.clid -a -f /opt/nuxeo/connect/connect.properties ]; then
        . /opt/nuxeo/connect/connect.properties
        if [ -n "$NUXEO_CONNECT_USERNAME" -a -n "$NUXEO_CONNECT_PASSWORD" -a -n "$NUXEO_STUDIO_PROJECT" ]; then
          echo "---> Registering instance on connect"
          nuxeoctl register $NUXEO_CONNECT_USERNAME $NUXEO_STUDIO_PROJECT dev openshift $NUXEO_CONNECT_PASSWORD
        fi
      fi

- apiVersion: v1
  kind: PersistentVolumeClaim
  metadata:
    name: ${APPLICATION_NAME}-uat-binaries
    labels:
      app: ${APPLICATION_NAME}-uat
      role: data
      stage: uat
  spec:
    accessModes:
    - ReadWriteMany
    resources:
      requests:
        storage: ${VOLUME_BINARIES_CAPACITY}
    storageClassName: shared


- apiVersion: v1
  kind: DeploymentConfig
  metadata:
    labels:
      app: ${APPLICATION_NAME}-uat
      stage: uat
      component: nuxeo
    name: ${APPLICATION_NAME}-uat-nuxeo
  spec:
    strategy:
      type: Rolling
      activeDeadlineSeconds: 21600
      resources: {}
      rollingParams:
        intervalSeconds: 1
        maxSurge: 25%
        maxUnavailable: 25%
        timeoutSeconds: 600
        updatePeriodSeconds: 1
    replicas: 1
    selector:
      app: ${APPLICATION_NAME}-uat
      component: nuxeo
      stage: uat
      deploymentconfig: ${APPLICATION_NAME}-uat-nuxeo

    template:
      metadata:
        labels:
          app: ${APPLICATION_NAME}-uat
          component: nuxeo
          stage: uat
          deploymentconfig: ${APPLICATION_NAME}-uat-nuxeo
      spec:
        containers:
        - image: ${APPLICATION_NAME}-nuxeo:latest
          imagePullPolicy: Always
          livenessProbe:
            httpGet:
              path: /nuxeo/runningstatus
              port: 8080
              scheme: HTTP
            initialDelaySeconds: 30
            timeoutSeconds: 5
            periodSeconds: 10
            successThreshold: 1
            failureThreshold: 3
          readinessProbe:
            failureThreshold: 3
            httpGet:
              path: /nuxeo/runningstatus
              port: 8080
              scheme: HTTP
            initialDelaySeconds: 20
            periodSeconds: 10
            successThreshold: 1
            timeoutSeconds: 5
          name: ${APPLICATION_NAME}-appserver
          env:
          - name: NUXEO_TEMPLATES
            value: "default,mongodb,mongodb-audit"
          - name: NUXEO_CUSTOM_PARAM
            value: |
              nuxeo.mongodb.server=mongodb://${APPLICATION_NAME}-mongo-0.${APPLICATION_NAME}-mongo:27017
              nuxeo.mongodb.dbname=${APPLICATION_NAME}-uat
              elasticsearch.client=RestClient
              elasticsearch.httpReadOnly.baseUrl=http://${APPLICATION_NAME}-elasticsearch:9200
              elasticsearch.indexName=${APPLICATION_NAME}-uat
              mail.transport.host=aws-smtp-relay.common-infra.svc
              mail.from=noreply@nuxeo.io

          - name: NUXEO_PACKAGES
            value: nuxeo-web-ui
          - name: NUXEO_URL
            value: https://${APPLICATION_NAME}-dev.${DOMAIN_SUFFIX}
          - name: NUXEO_ES_HOSTS
            value: ${APPLICATION_NAME}-elasticsearch:9200
          - name: NUXEO_ES_CLUSTERNAME
            value: ${ELASTICSEARCH_CLUSTER_NAME}
          - name: NUXEO_ES_REPLICAS
            value: "0"
          - name: NUXEO_BINARY_STORE
            value: /binaries

          ports:
          - containerPort: 8080
            protocol: TCP
          volumeMounts:
          - name: ${APPLICATION_NAME}-binaries
            mountPath: /binaries
          - name: nuxeoconf
            mountPath: /docker-entrypoint-initnuxeo.d
          - name: connect-secret
            mountPath: /opt/nuxeo/connect

          - name: nuxeodata
            mountPath: /var/lib/nuxeo/data
          - name: nuxeolog
            mountPath: /var/log/nuxeo
          - name: nuxeotmp
            mountPath: /opt/nuxeo/server/tmp
        volumes:
        - name: ${APPLICATION_NAME}-binaries
          persistentVolumeClaim:
            claimName: ${APPLICATION_NAME}-uat-binaries
        - name: nuxeoconf
          configMap:
            name: ${APPLICATION_NAME}-uat-conf
        - name: connect-secret
          secret:
            secretName: ${APPLICATION_NAME}-connect
        - name: nuxeodata
          emptyDir: {}
        - name: nuxeolog
          emptyDir: {}
        - name: nuxeotmp
          emptyDir: {}
        dnsPolicy: ClusterFirst
        restartPolicy: Always
        terminationGracePeriodSeconds: 30
    test: false
    triggers:
    - type: ConfigChange
    - type: "ImageChange"
      imageChangeParams:
        automatic: false
        containerNames:
        - ${APPLICATION_NAME}-appserver
        from:
          kind: ImageStreamTag
          name: ${APPLICATION_NAME}-nuxeo:latest

- apiVersion: v1
  kind: Service
  metadata:
    name: ${APPLICATION_NAME}-uat-nuxeo
    labels:
      app: ${APPLICATION_NAME}-uat
      component: nuxeo
      role: lb
  spec:
    clusterIP: None
    selector:
      app: ${APPLICATION_NAME}-uat
      component: nuxeo
      stage: uat
    ports:
    - name: 8080-tcp
      port: 8080
      protocol: TCP

- apiVersion: v1
  kind: Route
  metadata:
    labels:
      app: ${APPLICATION_NAME}-uat
    name: ${APPLICATION_NAME}-uat-nuxeo-route
  spec:
    # TODO: Add parameter
    host: ${APPLICATION_NAME}-uat.${DOMAIN_SUFFIX}
    tls:
      termination: edge
      insecureEdgeTerminationPolicy: Redirect
    to:
      kind: Service
      name: ${APPLICATION_NAME}-uat-nuxeo
    port:
      targetPort: 8080-tcp
    wildcardPolicy: None



############################################################################################################
# Build pipeline
############################################################################################################


- apiVersion: v1
  kind: ImageStream
  metadata:
    name: ${APPLICATION_NAME}-base-image
    labels:
      app: ${APPLICATION_NAME}
  spec: {}


- apiVersion: v1
  kind: BuildConfig
  metadata:
    labels:
      app: ${APPLICATION_NAME}
      component: build
    name: ${APPLICATION_NAME}-base-image-build
  spec:
    nodeSelector: null
    output:
      to:
        kind: ImageStreamTag
        name: '${APPLICATION_NAME}-base-image:latest'
    postCommit: {}
    resources: {}
    runPolicy: Serial
    source:
      dockerfile: |-
          FROM nuxeo:${NUXEO_VERSION}
          USER root

          # Reinstall ImageMagick with the RSVG delegate
          RUN apt-get update && \
              apt-get remove -y imagemagick && \
              apt-get install -y --no-install-recommends librsvg2-bin && \
              apt-get install -y imagemagick && \
              apt-get install -y --no-install-recommends vim && \
              echo Finished
          USER 1000
      type: Dockerfile
    strategy:
      dockerStrategy: {}
      type: Docker
    triggers:
    - type: ConfigChange


- apiVersion: build.openshift.io/v1
  kind: BuildConfig
  metadata:
    labels:
      app: ${APPLICATION_NAME}
      component: build
    name: ${APPLICATION_NAME}-app-build
  spec:
    nodeSelector: null
    postCommit: {}
    resources: {}
    runPolicy: Serial
    source:
      binary:
        asFile: source
      dockerfile: |-
        # Start from a Nuxeo base image
        FROM ${APPLICATION_NAME}-base-image:latest

        # Set up the /build folder with the install script, the marketplace package and the studio credentials
        USER root
        RUN mkdir -p /build/marketplace
        COPY install.sh /build
        COPY marketplace.zip /build/marketplace
        RUN chmod -R 777 /build
        COPY ./connect.properties /opt/nuxeo/connect/connect.properties
        RUN chmod 777 /opt/nuxeo/connect/connect.properties

        # Run the image build script
        USER 1000
        RUN /build/install.sh

        # Clean the server
        USER root
        RUN rm -f /opt/nuxeo/connect/connect.properties && \
            chgrp -fR 0 /opt/nuxeo/server/ && \
            chmod -fR g+rwX /opt/nuxeo/server/
        USER 1000
      secrets:
        - secret:
            name: ${APPLICATION_NAME}-connect
      type: Binary
    strategy:
      dockerStrategy:
        forcePull: true
        from:
          kind: ImageStreamTag
          name: ${APPLICATION_NAME}-base-image:latest
      type: Docker
    output:
      to:
        kind: ImageStreamTag
        name: ${APPLICATION_NAME}-nuxeo:latest
    successfulBuildsHistoryLimit: 2
    failedBuildsHistoryLimit: 2

- apiVersion: build.openshift.io/v1
  kind: BuildConfig
  metadata:
    annotations:
      pipeline.alpha.openshift.io/uses: '[{"name": "${APPLICATION_NAME}", "namespace": "", "kind": "DeploymentConfig"}]'
    labels:
      name: ${APPLICATION_NAME}-pipeline
    name: ${APPLICATION_NAME}-pipeline
  spec:
    nodeSelector: {}
    output: {}
    postCommit: {}
    resources: {}
    runPolicy: Serial
    source:
      type: None
    strategy:
      jenkinsPipelineStrategy:
        jenkinsfile: |-
          try {
              timeout(time: 20, unit: 'MINUTES') {
                  def project = ""
                  def packagePathRegExp = ""
                  node {
                      stage("Initialize") {
                          project = env.PROJECT_NAME
                          dir(env.JENKINS_HOME + "/configuration") {
                              def files = findFiles(glob: "**/settings.xml")
                              if (files.length == 0) {
                                  echo "Maven settings file not found."
                              }
                              stash name:"mavenSettings", includes:"${files[0]}"
                          }
                      }
                    }
                  node("jenkins-slave") {
                      stage("Checkout Repository") {
                        git url: "${SOURCE_REPOSITORY_URL}",
                        credentialsId: "${project}-${APPLICATION_NAME}-github-ssh",
                        branch: "${SOURCE_REPOSITORY_REF}"
                      }
                      stage("Build Nuxeo Package") {
                          withMaven() {
                              withCredentials([
                                  usernamePassword(
                                      credentialsId: "${project}-${APPLICATION_NAME}-connect-credentials",
                                      usernameVariable: "NUXEO_CONNECT_USERNAME",
                                      passwordVariable: "NUXEO_CONNECT_PASSWORD"
                                  )
                              ]) {
                                  unstash name: "mavenSettings"
                                  def mavenSettings = findFiles(glob: "**/settings.xml")[0]
                                  sh "mvn --settings ${mavenSettings.path} clean package -DskipITs"
                                  if (fileExists(".nuxeo-s2i")) {
                                      def props = readProperties file: ".nuxeo-s2i"
                                      packagePathRegExp = props["NUXEO_PACKAGE_DIR"]
                                  } else {
                                      packagePathRegExp = "*(marketplace|package)-*.zip"
                                  }
                                  def files = findFiles(glob: "**/${packagePathRegExp}")
                                  if (files.length == 0) {
                                      echo "Marketplace zip file not found."
                                  }
                                  stash name:"marketplace", includes:"${files[0]}"
                              }
                          }
                      }
                    }
                  node {
                      stage("Build Image") {
                          unstash name: "marketplace"
                          def files = findFiles(glob: "**/${packagePathRegExp}")
                          if (files.length == 0) {
                              echo "Marketplace zip file not found."
                          }
                          if (fileExists("source")) {
                              sh "rm -rf source"
                          }
                          sh "mkdir -p source"
                          fileOperations([
                              fileCopyOperation(
                                  includes: "${files[0].path}",
                                  targetLocation: "source",
                                  flattenFiles: true,
                              ),
                              fileRenameOperation(
                                  source: "source/${files[0].name}",
                                  destination: "source/marketplace.zip"
                              ),
                              fileDownloadOperation(
                                  url: "https://raw.githubusercontent.com/nuxeo-sandbox/nuxeo-s2i/${NUXEO_VERSION}/contrib/install.sh",
                                  userName: "",
                                  password: "",
                                  targetLocation: "source",
                                  targetFileName: "install.sh"
                              )
                          ])
                          sh "oc start-build ${APPLICATION_NAME}-app-build --from-dir='source' -n ${project}"
                          openshiftVerifyBuild bldCfg: "${APPLICATION_NAME}-app-build", waitTime: '20', waitUnit: 'min'
                      }
                      stage("Deploy to DEV Env") {
                          openshiftDeploy(deploymentConfig: "${APPLICATION_NAME}-dev-nuxeo")
                      }
                      stage("Run ftests") {
                          def packageFile = findFiles(glob: "**/${APPLICATION_NAME}-ftest/**/package.json")
                          if (packageFile.length == 0) {
                              echo "No NodeJs functional tests to run."
                          } else {
                              openshift.withCluster() {
                                  openshift.withProject() {
                                      def nuxeoUrl = "https://" + openshift.selector("route/${APPLICATION_NAME}-dev-nuxeo-route").object().spec.host + "/nuxeo/"
                                      timeout(time: 15, unit: "MINUTES") {
                                          def dcLatestVersion = openshift.selector("dc", "${APPLICATION_NAME}-dev-nuxeo").object().status.latestVersion
                                          def rc = openshift.selector('rc', "${APPLICATION_NAME}-dev-nuxeo-${dcLatestVersion}")
                                          rc.untilEach(1){
                                              def rcMap = it.object()
                                              return (rcMap.status.replicas.equals(rcMap.status.readyReplicas))
                                          }
                                          withEnv(["NUXEO_URL=${nuxeoUrl}"]) {
                                              sh "mvn verify -pl=${APPLICATION_NAME}-ftest -DskipNodeITs=false"
                                          }
                                      }
                                  }
                              }
                          }
                      }
                      timeout(time: 60, unit: 'MINUTES') {
                        node {
                            stage("User Validate") {
                                input message: "Do you want to deploy to UAT environment too?", id: "approval"
                            }
                        }
                        node {
                            stage("Deploy to UAT Env") {
                                openshiftDeploy(deploymentConfig: "${APPLICATION_NAME}-uat-nuxeo")
                            }
                        }
                      }
                  }
              }
          } catch (err) {
             echo "in catch block"
             echo "Caught: ${err}"
             currentBuild.result = 'FAILURE'
             throw err
          }
      type: JenkinsPipeline
    triggers:
    - github:
        secret: ${GITHUB_WEBHOOK_SECRET}
      type: GitHub
    successfulBuildsHistoryLimit: 10
    failedBuildsHistoryLimit: 5

- apiVersion: v1
  kind: BuildConfig
  metadata:
    labels:
      name: ${APPLICATION_NAME}-reset-dev
    name: ${APPLICATION_NAME}-reset-dev
  spec:
    strategy:
      jenkinsPipelineStrategy:
        jenkinsfile: |-
          properties([
            [$class: 'BuildDiscarderProperty', strategy: [$class: 'LogRotator', daysToKeepStr: '5', numToKeepStr: '5', artifactNumToKeepStr: '1']]
          ])
          try {
            timeout(time: 60, unit: 'MINUTES') {
              node {
                stage("confirm") {
                  input message: "Do you really want to reset data for Dev environment? All data will be lost.", id: "approval"
                }
              }
              node {
                project = env.PROJECT_NAME
                stage("stop nuxeo pod") {
                  sh "oc scale dc/${APPLICATION_NAME}-dev-nuxeo --replicas=0"
                }
                stage('drop db') {
                  sh "oc get pod -l component=mongo --template='{{range .items}}{{.metadata.name}}{{end}}' > podname"
                  podMongo = readFile('podname').trim()
                  sh '''oc exec ''' + podMongo + ''' -- bash -c 'mongo ${APPLICATION_NAME}-dev --eval "printjson(db.dropDatabase())"'   '''
                }
                stage('drop es indexes') {
                  sh "oc get pod -l component=elasticsearch --template='{{range .items}}{{.metadata.name}}{{end}}' > podname"
                  podElastic = readFile('podname').trim()
                  sh '''oc exec ''' + podElastic + ''' -- bash -c "curl -XDELETE http://localhost:9200/${APPLICATION_NAME}-dev-uidgen"'''
                  sh '''oc exec ''' + podElastic + ''' -- bash -c "curl -XDELETE http://localhost:9200/${APPLICATION_NAME}-dev-audit"'''
                  sh '''oc exec ''' + podElastic + ''' -- bash -c "curl -XDELETE http://localhost:9200/${APPLICATION_NAME}-dev"'''
                }
                stage("restart nuxeo pod") {
                  sh "oc scale dc/${APPLICATION_NAME}-dev-nuxeo --replicas=1"
                }
                stage("wait for pod") {
                    isAwait = true
                    while (isAwait) {
                      sh "oc get dc/${APPLICATION_NAME}-dev-nuxeo --template='{{.status.availableReplicas}}'  > status"
                      status = readFile('status').trim()
                      if (status.toString().equals("1")) {
                          isAwait = false
                      } else {
                          sleep(time: 30, unit: 'SECONDS')
                      }
                    }
                  }
              }
            }
          } catch (err) {
             echo "in catch block"
             echo "Caught: ${err}"
             currentBuild.result = 'FAILURE'
             throw err
          }

- apiVersion: v1
  kind: BuildConfig
  metadata:
    labels:
      name: ${APPLICATION_NAME}-reset-uat
    name: ${APPLICATION_NAME}-reset-uat
  spec:
    strategy:
      jenkinsPipelineStrategy:
        jenkinsfile: |-
          properties([
            [$class: 'BuildDiscarderProperty', strategy: [$class: 'LogRotator', daysToKeepStr: '5', numToKeepStr: '5', artifactNumToKeepStr: '1']]
          ])
          try {
            timeout(time: 60, unit: 'MINUTES') {
              node {
                stage("confirm") {
                  input message: "Do you really want to reset data for UAT environment? All data will be lost.", id: "approval"
                }
              }
              node {
                project = env.PROJECT_NAME
                stage("stop nuxeo pod") {
                  sh "oc scale dc/${APPLICATION_NAME}-uat-nuxeo --replicas=0"
                }
                stage('drop db') {
                  sh "oc get pod -l component=mongo --template='{{range .items}}{{.metadata.name}}{{end}}' > podname"
                  podMongo = readFile('podname').trim()
                  sh '''oc exec ''' + podMongo + ''' -- bash -c 'mongo ${APPLICATION_NAME}-uat --eval "printjson(db.dropDatabase())"'   '''
                }
                stage('drop es indexes') {
                  sh "oc get pod -l component=elasticsearch --template='{{range .items}}{{.metadata.name}}{{end}}' > podname"
                  podElastic = readFile('podname').trim()
                  sh '''oc exec ''' + podElastic + ''' -- bash -c "curl -XDELETE http://localhost:9200/${APPLICATION_NAME}-uat-uidgen"'''
                  sh '''oc exec ''' + podElastic + ''' -- bash -c "curl -XDELETE http://localhost:9200/${APPLICATION_NAME}-uat-audit"'''
                  sh '''oc exec ''' + podElastic + ''' -- bash -c "curl -XDELETE http://localhost:9200/${APPLICATION_NAME}-uat"'''
                }
                stage("restart nuxeo pod") {
                  sh "oc scale dc/${APPLICATION_NAME}-uat-nuxeo --replicas=1"
                }
                stage("wait for pod") {
                    isAwait = true
                    while (isAwait) {
                      sh "oc get dc/${APPLICATION_NAME}-uat-nuxeo --template='{{.status.availableReplicas}}'  > status"
                      status = readFile('status').trim()
                      if (status.toString().equals("1")) {
                          isAwait = false
                      } else {
                          sleep(time: 30, unit: 'SECONDS')
                      }
                    }
                  }
              }
            }
          } catch (err) {
             echo "in catch block"
             echo "Caught: ${err}"
             currentBuild.result = 'FAILURE'
             throw err
          }


############################################################################################################
# Release pipeline
############################################################################################################

- apiVersion: v1
  data:
    user.name: ${NUXEO_RELEASE_GIT_USERNAME}
    user.email: ${NUXEO_RELEASE_GIT_EMAIL}
  kind: ConfigMap
  metadata:
    name: ${APPLICATION_NAME}-gitconfig

- apiVersion: build.openshift.io/v1
  kind: BuildConfig
  metadata:
    annotations:
      pipeline.alpha.openshift.io/uses: '[{"name": "${APPLICATION_NAME}", "namespace": "", "kind": "DeploymentConfig"}]'
    labels:
      name: ${APPLICATION_NAME}-release-pipeline
    name: ${APPLICATION_NAME}-release-pipeline
  spec:
    nodeSelector: {}
    output: {}
    postCommit: {}
    resources: {}
    runPolicy: Serial
    source:
      type: None
    strategy:
      jenkinsPipelineStrategy:
        jenkinsfile: |-
          try {
              timeout(time: 20, unit: 'MINUTES') {
                  def project = ""
                  def nuxeoReleaseGitUsername = ""
                  def nuxeoReleaseGitEmail = ""
                  def sshPrivateKey = ""
                  def instanceClid = ""
                  def homeJenkins = ""
                  def externalReleasesUrl = ""

                  node {
                      stage("Choose the release scope") {
                        script {
                          env.RELEASE_SCOPE = input message: "What is the increment version release scope?",
                            ok: "Release",
                            parameters: [choice(
                              name: "Release scope",
                              choices: "patch\nminor\nmajor",
                              description: "For instance, patch: 1.2.3 => 1.2.4 / minor: 1.2.3 => 1.3.0 / major: 1.2.3 => 2.0.0"
                            )]
                        }
                      }
                      stage("Initialize") {
                          project = env.PROJECT_NAME
                          nuxeoReleaseGitUsername = env.NUXEO_RELEASE_GIT_USERNAME
                          nuxeoReleaseGitEmail = env.NUXEO_RELEASE_GIT_EMAIL
                          sshPrivateKey = env.SSH_PRIVATEKEY
                          instanceClid = env.INSTANCE_CLID
                          autoIncrementPolicy = "auto_" + env.RELEASE_SCOPE
                          homeJenkins = "/home/jenkins"

                          dir("/var/lib/jenkins/configuration") {
                              def files = findFiles(glob: "**/settings.xml")
                              if (files.length == 0) {
                                  echo "Maven settings file not found."
                              }
                              stash name:"mavenSettings", includes:"${files[0]}"
                          }
                      }
                  }
                  node("jenkins-slave") {
                      stage("Checkout Repository") {
                          git url: "${SOURCE_REPOSITORY_URL}",
                          credentialsId: "${project}-${APPLICATION_NAME}-github-ssh",
                          branch: "${SOURCE_REPOSITORY_REF}"
                      }
                      stage("Setup workspace") {
                          // Put SSH key in .ssh/
                          fileOperations([
                              fileCreateOperation(
                                  fileName: "${homeJenkins}/.ssh/id_rsa",
                                  fileContent: "${sshPrivateKey}"
                              )
                          ])
                          sh "chmod 600 ${homeJenkins}/.ssh/id_rsa"

                          // Put maven settings in .m2/
                          unstash name: "mavenSettings"
                          def mavenSettings = findFiles(glob: "**/settings.xml")[0]
                          sh "mv ${mavenSettings.path} ${homeJenkins}/.m2/settings.xml"

                          // Setup git config
                          sh "git config --global user.name ${nuxeoReleaseGitUsername}"
                          sh "git config --global user.email ${nuxeoReleaseGitEmail}"

                          // Put instance.clid in ftests resources
                          def ftests = findFiles(glob: "**/ftest/**/itests.xml")
                          if (ftests.length > 0) {
                              def itestsPath = ftests[0].path
                              def clidPath = itestsPath.replace("itests.xml", "src/main/resources/instance.clid")
                              fileOperations([
                                  fileCreateOperation(
                                      fileName: "${clidPath}",
                                      fileContent: "${instanceClid}"
                                  )
                              ])
                          }

                          // Get external releases repository URL
                          sh "oc get route/${APPLICATION_NAME}-nexus -o json > nexus-route.json"
                          def nexusRoute = readJSON(file: "nexus-route.json")
                          externalReleasesUrl = "http://" + nexusRoute.spec.host + nexusRoute.spec.path + "/content/repositories/releases"
                      }
                      stage("Build Release") {
                          // Download release script and put SSH key file in .ssh/
                          def operations = []
                          def files = ["release.py", "requirements.txt", "IndentedHelpFormatterWithNL.py", "nxutils.py", "terminalsize.py"]
                          files.each { file -> operations.add(
                              fileDownloadOperation(
                                  url: "https://raw.githubusercontent.com/nuxeo/nuxeo/release-${NUXEO_VERSION}/scripts/${file}",
                                  userName: "",
                                  password: "",
                                  targetLocation: "",
                                  targetFileName: "${file}"
                              )
                          )}
                          fileOperations(operations)

                          // Launch release and deploy artifacts to Nexus
                          withCredentials([
                              usernamePassword(
                                  credentialsId: "${project}-${APPLICATION_NAME}-connect-credentials",
                                  usernameVariable: "NUXEO_CONNECT_USERNAME",
                                  passwordVariable: "NUXEO_CONNECT_PASSWORD"
                              ),
                              usernamePassword(
                                  credentialsId: "${project}-${APPLICATION_NAME}-nexus-credentials",
                                  usernameVariable: "NEXUS_ADMIN_USERNAME",
                                  passwordVariable: "NEXUS_ADMIN_PASSWORD"
                              )
                          ]) {
                              env.EXTERNAL_RELEASES_URL = externalReleasesUrl
                              withMaven() {
                                  sh "python ./release.py -f prepare --aip=${autoIncrementPolicy}"
                                  sh "python ./release.py perform"
                              }
                          }
                      }
                  }
              }
          } catch (err) {
              echo "in catch block"
              echo "Caught: ${err}"
              currentBuild.result = 'FAILURE'
              throw err
          }
      type: JenkinsPipeline
